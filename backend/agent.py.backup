"""LangChain agent with MCP tools integration."""

import logging
from typing import Any, Dict, List, Optional

from langchain.agents import AgentExecutor, create_tool_calling_agent
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import Tool

from mcp_client import mcp_manager
from llm import llm_manager

logger = logging.getLogger(__name__)


class MCPToolWrapper:
    """Wrapper to convert MCP tools to LangChain tools."""

    def __init__(self, server_name: str, tool_name: str, tool_description: str):
        """
        Initialize MCP tool wrapper.

        Args:
            server_name: MCP server name (shell, filesystem, chrome)
            tool_name: Tool name on the MCP server
            tool_description: Tool description for LLM
        """
        self.server_name = server_name
        self.tool_name = tool_name
        self.tool_description = tool_description

    async def __call__(self, **kwargs) -> str:
        """Execute the MCP tool."""
        try:
            result = await mcp_manager.call_tool(
                server_name=self.server_name,
                tool_name=self.tool_name,
                arguments=kwargs,
            )

            # Extract text content from MCP response
            if isinstance(result, list) and len(result) > 0:
                return result[0].text
            return str(result)

        except Exception as e:
            error_msg = f"Error calling {self.tool_name}: {str(e)}"
            logger.error(error_msg)
            return error_msg


async def create_mcp_tools() -> List[Tool]:
    """
    Create LangChain tools from all MCP servers.

    Returns:
        List of LangChain Tool instances
    """
    logger.info("Creating LangChain tools from MCP servers...")

    tools = []

    # Define which tools to expose to the agent
    # You can customize this based on your needs
    tool_configs = [
        # Shell MCP tools
        {
            "server": "shell",
            "name": "execute_command",
            "description": (
                "Execute a shell command in the sandbox. "
                "Use this to run commands like ls, cat, python, node, etc. "
                "Arguments: command (str), args (list), cwd (str, optional)"
            ),
        },
        {
            "server": "shell",
            "name": "get_running_processes",
            "description": (
                "Get list of running processes in the sandbox with CPU and memory usage. "
                "No arguments required."
            ),
        },
        # Filesystem MCP tools
        {
            "server": "filesystem",
            "name": "read_file",
            "description": (
                "Read contents of a file in the sandbox workspace. "
                "Arguments: path (str), encoding (str, default 'utf-8')"
            ),
        },
        {
            "server": "filesystem",
            "name": "write_file",
            "description": (
                "Write content to a file in the sandbox workspace. "
                "Arguments: path (str), content (str), mode (str, 'w' or 'a')"
            ),
        },
        {
            "server": "filesystem",
            "name": "list_directory",
            "description": (
                "List files and directories in the workspace. "
                "Arguments: path (str, default '.'), recursive (bool, default false)"
            ),
        },
        # Chrome MCP tools
        {
            "server": "chrome",
            "name": "launch_browser",
            "description": (
                "Launch Chrome browser in the sandbox VNC display. "
                "Arguments: headless (bool, default false), display (str, default ':1')"
            ),
        },
        {
            "server": "chrome",
            "name": "navigate_to_url",
            "description": (
                "Navigate browser to a URL. Browser must be launched first. "
                "Arguments: url (str), wait_until (str, default 'load')"
            ),
        },
        {
            "server": "chrome",
            "name": "get_page_content",
            "description": (
                "Get HTML and text content from current browser page. "
                "Arguments: selector (str, default 'body')"
            ),
        },
        {
            "server": "chrome",
            "name": "take_screenshot",
            "description": (
                "Take screenshot of current browser page. "
                "Arguments: filename (str), full_page (bool, default false)"
            ),
        },
    ]

    for config in tool_configs:
        wrapper = MCPToolWrapper(
            server_name=config["server"],
            tool_name=config["name"],
            tool_description=config["description"],
        )

        tool = Tool(
            name=f"{config['server']}_{config['name']}",
            func=wrapper,  # For sync calls (LangChain will handle async)
            coroutine=wrapper,  # For async calls
            description=config["description"],
        )

        tools.append(tool)

    logger.info(f"Created {len(tools)} LangChain tools from MCP servers")

    return tools


class SandboxAgent:
    """LangChain agent with MCP tools for sandbox control."""

    def __init__(self):
        """Initialize the sandbox agent."""
        self.llm = None
        self.agent_executor: Optional[AgentExecutor] = None
        self.tools: List[Tool] = []

    async def initialize(self):
        """Initialize the agent with LLM and tools."""
        logger.info("Initializing Sandbox Agent...")

        # Get LLM
        self.llm = llm_manager.get_or_create_llm()

        # Create MCP tools
        self.tools = await create_mcp_tools()

        # Create agent prompt
        prompt = ChatPromptTemplate.from_messages([
            ("system", (
                "You are a helpful AI assistant with access to a sandbox environment. "
                "You can execute shell commands, manage files, and control a Chrome browser. "
                "All operations happen in a Docker container with VNC display at :1. "
                "\n\n"
                "Available tools:\n"
                "- Shell commands (execute_command, get_running_processes)\n"
                "- File operations (read_file, write_file, list_directory)\n"
                "- Browser control (launch_browser, navigate_to_url, get_page_content, take_screenshot)\n"
                "\n"
                "Always be helpful and explain what you're doing. "
                "If something fails, try to diagnose and fix the issue."
            )),
            ("placeholder", "{chat_history}"),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ])

        # Create agent
        agent = create_tool_calling_agent(self.llm, self.tools, prompt)

        # Create executor
        self.agent_executor = AgentExecutor(
            agent=agent,
            tools=self.tools,
            verbose=True,
            max_iterations=10,
            handle_parsing_errors=True,
        )

        logger.info("Sandbox Agent initialized successfully")

    async def run(self, user_input: str, chat_history: Optional[List] = None) -> str:
        """
        Run the agent with user input.

        Args:
            user_input: User's message/question
            chat_history: Optional chat history

        Returns:
            Agent's response
        """
        if self.agent_executor is None:
            await self.initialize()

        logger.info(f"Running agent with input: {user_input}")

        result = await self.agent_executor.ainvoke({
            "input": user_input,
            "chat_history": chat_history or [],
        })

        return result["output"]


# Global agent instance
sandbox_agent = SandboxAgent()
